---
import type { MarkdownHeading } from "astro";

interface Props {
  headings?: MarkdownHeading[];
}

const { headings } = Astro.props;
---

{
  headings?.length && (
    <nav class="toc" aria-labelledby="tocHeader">
      <h2 class="toc-header" id="tocHeader">
        On this page
      </h2>
      <ul>
        {headings.map(({ depth, slug, text }) => (
          <li style={"--depth: " + depth}>
            <a href={`#${slug}`}>{text}</a>
          </li>
        ))}
      </ul>
    </nav>
  )
}
<script>
  import { annotate } from "rough-notation";
  import type { RoughAnnotation } from "rough-notation/lib/model";

  const toc = document.querySelector(".toc")!;
  const tocMap = new Map<
    HTMLHeadingElement,
    { annotation: RoughAnnotation; rect: DOMRect }
  >();

  let activeHeading: HTMLHeadingElement | null = null;
  let lastY = 0;
  // 1 => scrolling down, -1 => scrolling up
  let scrollDir = 1;

  /** On next frame, update the scroll dir and lastY */
  const update = () => {
    if (window.scrollY != lastY) {
      scrollDir = window.scrollY - lastY > 0 ? 1 : -1;
      lastY = window.scrollY;
    }
    requestAnimationFrame(update);
  };
  requestAnimationFrame(update);

  const io = new IntersectionObserver(
    (entries) => {
      for (const entry of entries) {
        if (Object.is(entry.target, activeHeading)) continue;

        if (entry.intersectionRatio > 0.5) {
          const target = entry.target as HTMLHeadingElement;
          const { annotation, rect } = tocMap.get(target)!;
          const activeConfig = tocMap.get(activeHeading!)!;
          if (activeConfig) {
            // if scrolling down and the active heading is
            // higher on the page than the new heading
            if (scrollDir > 0 && activeConfig.rect.y < rect.y) {
              activeConfig.annotation.hide();
              annotation.show();
              activeHeading = target;

              // if scrolling up and the active heading is lower
              // on the page than the new heading
            } else if (scrollDir < 0 && activeConfig.rect.y > rect.y) {
              activeConfig.annotation.hide();
              annotation.show();
              activeHeading = target;
            }
          } else {
            activeHeading = target;
          }
        }
      }
    },
    {
      threshold: Array.from({ length: 100 }, (_, i) => i * 0.01),
    },
  );

  toc.querySelectorAll("a").forEach((item) => {
    const id = new URL(item.href).hash;
    const heading = document.querySelector<HTMLHeadingElement>(id)!;

    const underline = annotate(item, {
      type: "underline",
      animate: false,
      iterations: 1,
      multiline: true,
      padding: 0,
    });
    tocMap.set(heading, {
      annotation: underline,
      rect: heading.getBoundingClientRect(),
    });
    io.observe(heading);
  });
</script>
<style>
  @media (min-width: 576px) {
    nav {
      position: sticky;
      top: var(--space-xl);
      right: 0;
      /* `display: grid` will extend the height of this past it's content, let's stop that */
      max-height: fit-content;
    }
  }

  h2 {
    font-size: var(--step-0);
  }

  ul {
    list-style-type: none;
    padding-inline-start: 0;
    padding-block: var(--space-l);
    display: flex;
    flex-flow: column;
    gap: var(--space-2xs);
  }

  li {
    font-size: var(--step--1);
    margin-inline-start: calc((var(--depth) - 2) * var(--space-m));
  }

  a {
    text-decoration: 1px solid transparent;
  }
</style>
