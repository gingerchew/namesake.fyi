---
import type { MarkdownHeading } from "astro";

interface Props {
  headings?: MarkdownHeading[];
}

const { headings } = Astro.props;
---

{
  headings?.length && (
    <nav class="toc" aria-labelledby="tocHeader">
      <h2 class="toc-header" id="tocHeader">
        On this page
      </h2>
      <table-of-contents>
        <ul>
          {headings.map(({ depth, slug, text }) => (
            <li style={"--depth: " + depth}>
              <a href={`#${slug}`}>{text}</a>
            </li>
          ))}
        </ul>
      </table-of-contents>
    </nav>
  )
}
<script>
  import { annotate } from "rough-notation";
  import type { RoughAnnotation } from "rough-notation/lib/model";

  customElements.define(
    "table-of-contents",
    class extends HTMLElement {
      #topIO: IntersectionObserver;
      #bottomIO: IntersectionObserver;
      #links: HTMLAnchorElement[];
      #headings: HTMLHeadingElement[];
      #annotations: Map<HTMLAnchorElement, RoughAnnotation>;
      #index = 0;

      set activeIndex(v: number) {
        let nextIndex = v;
        if (v < 0) nextIndex = 0;
        if (v >= this.#headings.length) v = this.#headings.length - 1;
        this.#index = nextIndex;
      }
      get activeIndex() {
        return this.#index;
      }

      constructor() {
        super();
        this.#annotations = new Map();
        const middle = window.innerHeight / 2;

        this.#topIO = new IntersectionObserver(
          (entries, _obs) => {
            for (const entry of entries) {
              if (entry.isIntersecting) {
                const { boundingClientRect } = entry;
                /**
                 * If the boundingClientRect.top is greater than 0,
                 * we can safely assume the element is scrolling into the top
                 * half of the screen from the bottom half
                 *
                 * This means we can hide the active annotation, and
                 * show the next annotation in the index
                 */
                if (boundingClientRect.top > 0) {
                  this.getAnnotationFromIndex(this.activeIndex)?.hide();
                  this.activeIndex = this.#headings.indexOf(
                    entry.target as HTMLHeadingElement,
                  );
                  this.getAnnotationFromIndex(this.activeIndex)?.show();
                }
              }
            }
          },
          {
            threshold: 0,
            rootMargin: "0px 0px " + -middle + "px 0px",
          },
        );

        this.#bottomIO = new IntersectionObserver(
          (entries, _obs) => {
            for (const entry of entries) {
              if (entry.isIntersecting) {
                const { boundingClientRect } = entry;
                /**
                 * If the boundingclientRect.bottom is < window.innerHeight
                 * we cans afely assume the element is scrolling into the
                 * bottom half of the viewport from the top half
                 *
                 * this means we can deactivate the associated annotation
                 * and go to the previous heading and activate that
                 */
                if (boundingClientRect.bottom < window.innerHeight) {
                  this.getAnnotationFromIndex(this.activeIndex)?.hide();
                  // If we're at the very first heading and it is going off screen,
                  // don't try to annotate the previous one
                  if (this.activeIndex !== 0) {
                    this.activeIndex =
                      this.#headings.indexOf(
                        entry.target as HTMLHeadingElement,
                      ) - 1;
                    this.getAnnotationFromIndex(this.activeIndex)?.show();
                  }
                }
              }
            }
          },
          {
            threshold: 0,
            rootMargin: -middle + "px 0px 0px 0px",
          },
        );

        this.#items = Array.from(this.querySelectorAll("a"));
        this.#headings = [];

        this.#items.forEach((link) => {
          const { hash } = new URL(link.href);
          const heading = document.querySelector<HTMLHeadingElement>(hash);

          if (!heading) return;

          this.#headings.push(heading);
          this.#topIO.observe(heading);
          this.#bottomIO.observe(heading);
        });
      }

      getAnnotationFromIndex(i: number): RoughAnnotation | null {
        if (i < 0 || i > this.#items.length - 1) return null;
        const item = this.#items[i];

        if (!this.#annotations.has(item)) {
          this.#annotations.set(
            item,
            annotate(item, {
              type: "underline",
              animate: false,
              iterations: 1,
              multiline: true,
              padding: 0,
            }),
          );
        }

        return this.#annotations.get(item)!;
      }
    },
  );
</script>
<style>
  h2 {
    font-size: var(--step-0);
  }

  ul {
    list-style-type: none;
    padding-inline-start: 0;
    padding-block: var(--space-l);
    display: flex;
    flex-flow: column;
    gap: var(--space-2xs);
  }

  li {
    font-size: var(--step--1);
    margin-inline-start: calc((var(--depth) - 2) * var(--space-m));
  }

  a {
    text-decoration: 1px solid transparent;
  }
</style>
